散列表
一、直接寻址表
	为表示动态集合，我们用一个数组，或称为直接寻址表，记为T[0..m-1]。其中每个位置，或称为槽，对应全域U中的一个关键字。槽k指向集合中一个关键字为k的元素，如果集合中没有关键字为k的元素，则T[k]=NIL
	缺点：如果全域U很大，则所需存储空间太大，且实际使用的关键字集合K可能很小，造成空间浪费。

二、散列表
1.定义
	在直接寻址方式下，具有关键字k的元素被存放在槽k中。在散列方式下，该元素存放在槽h(K)中，即利用散列函数h，有关键字k计算出槽的位置。这里散列函数将关键字的全域映射到散列表T[0..m-1]的槽位上，关键字k经映射得到的槽数h(k)为关键字k的散列值。
	至少支持INSERT，SEARCH，DELETE三种字典操作
2.问题
	两个关键字可能映射到同一个槽中。这种情形称为冲突。
	解决方法：链接法，开放寻址法。。
3.链接法
（1)原理：
	把散列到同一个槽中的所有元素都放在一个链表中。如果散列表支持删除操作，则为了能够更快的删除某一元素，应该将其链表设计为双向链接的。
（2)装载因子：
	给定一个能存放n个元素的，具有m个槽位的散列表T，定义T的装载因子alpha为n/m
（3)散列函数
	-一个好的散列函数应（近似的）满足简单均匀散列假设：每个关键字都被等可能的散列到m个槽位中的任何一个，并与其他关键字已散列到哪个槽位无关。
	-除法散列法
		通过取k除以m的余数，将关键字k映射到m个槽位中的某一个上，即散列函数为：
			h(k) = k mod m
		选m=2^p-1可能是一个和糟糕的选择，一个不太接近2的整数幂的素数，常常是m的一个较好的选择。
	-乘法散列法
		第一步用关键字k乘上常数A（0<A<1),并提取kA的小数部分。
		第二步用m乘以这个值，再向下取整。散列函数为：
			h(k)=[m(kA mod 1)]=[m(kA-[kA])]
		对m的选择不是特别关键，一般选择它为2的某个幂次便于计算，A也不是很关键，0.618效果更好。
	-全域散列法*
		上两种是启发式，该方法是随机方法
4.开放寻址法
(1).定义
	所有的元素都存放在散列表里。也就是说，每个表项或包含动态集合的一个元素，或包含NIL。当查找某个元素时，要系统的检查所有的表项，知道找到所需的元素，或最终查明该元素不在表中。
(2).探查
	为了使用开放寻址法插入一个元素，需要连续的检查散列表，称为探查，直到找到一个空槽来放置待插入的关键字。
	对于每一个关键字k，使用开放寻址法的探查序列<h(k,0>,h(k,1)...h(k,m-1)>是<0,1...m-1>的一个排列。探查时按照探查序列来检查，而不是按0,1...的顺序一一检查。
	常用的探查序列包括：线性探查、二次探查、双重探查。最后一个效果好，用的多。
(3).探查序列
	-线性探查
		给定一个普通的散列函数h':U->{0,1,...,m-1},称为辅助散列函数，线性探查采用的散列函数为
			h(k,i)=(h'(k)+i)mod m     i=0,1,...m-1
	-二次探查
			h(k,i)=(h'(k)+c1i+c2i^2)mod m		i=0,1,...m-1
	-双重散列
		需要两个辅助散列函数h1,h2
			h(k,i)=(h1(k)+i*h2(k)mod m		i=0,1,...m-1
(4).删除
	删除时不能标为NIL，因为会影响查询（其实数由于当时优先槽被占用，放在了次优先槽），认为不在表中。可以标为DELETE
(5).参考
	http://blog.csdn.net/xiaojiasheng/article/details/47208041
