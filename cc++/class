一、声明与定义
1.声明.h
class Point
{
public:
     void setPoint(int x, int y);
private:
     int xPos;
     int yPos;
};  	//要有分号的
2.定义.cpp
Point::setPoint(int x,int y){}
3.内联方法
    定义在类声明中的函数都将自动成为内联函数
    内联函数的特殊规则要求在每个使用它们的文件中都对其进行定义。
    也可在类声明外定义内联函数，使用inline限定符。
    最简便的方法是将内联定义放在定义类的头文件中。
4.参考网站
	http://www.cnblogs.com/xiongxuanwen/p/4290086.html
	
二、构造函数与析构函数
1.成员名与参数名
    为了区分成员名和参数名，可以在成员名前面加前缀m_或在后面加后缀_
2.使用构造函数
    Stock food = Stock("hello");	//显式调用
    Stock food("hello");		//隐式调用
    Stock *pFood = new Stock("hello")	//动态分配
3.默认构造函数    
    隐式默认构造函数Stock::Stock(){}不做任何初始化工作。这样可以声明Stock stock;
    当且仅当没有定义任何构造函数时，编译器才会提供默认构造函数。
    如果为类定义了构造函数后，程序员就必须为它提供默认构造函数，即
    如果提供了Stock(const char* str),也必须提供Stock()，否则无法声明Stock stock;
    可以通过（1）提供默认值的方法Stock(const char* str = "hello")或
    （2）重载的方法Stock()来提供默认构造函数，但不要同时使用。
4.析构函数
    当对象过期时，程序调用析构函数完成清理工作。
    如果构造函数使用new来分配内存，则析构函数将使用delete来释放这些内存。
    如果构造函数没有使用new，析构函数没有需要完成的任务，使用隐式析构函数即可。
5.类内常量
    const int Months = 12;	//错误，在创建对象前没有用于存储值的空间
可用方法
（1）枚举
    enum {Months = 12};
    double costs[Moths];    
（2）static
    static const int Months = 12;
6.静态类成员
    不能在类声明中初始化静态成员变量，这是因为声明描述了如何分配内存，但并不分配内存。
对于静态类成员，可以在类声明之外使用单独的语句进行初始化（使用作用于运算符，但不使用static）。
这是因为静态类成员是单独存储的，而不是对象的组成部分。
对于不能在类声明中初始化静态数据成员的一种例外是，静态数据成员位整形或枚举型const。
如static int numStr; int StrBad::numStr=0;
三、运算符重载
1.格式
operatorop(argument-list)
如Time operator+(const Time &t) const{...}
Time t1,t2,t3;
t3 = t1 + t2;	//相当于Time对象t1调用方法operator+()，参数是t2,并返回一个Time对象。(运算符表示法）
也可以使用 t3 = t1.operator+(t2);（函数表示法）

2.重载限制
（1）重载后的运算符，至少有一个操作数是用户定义的类型。
（2）使用运算符时不能违反运算符原来的句法规则和优先级。
（3）不能创建新运算符。
可重载的运算符：
+;-;*;/;%;^;&;|;~=;!;=;<;>;+=;-=;*=;/=;...
（4）不能重载下面运算符
-sizeof
-.	//成员运算符
-*	//成员指针运算符
-::	//作用域解析
-?:	//条件运算符
-typeid;const_cast;dynamic_cast;reinterpret_cast;static_cast


四、拷贝与赋值
1.定义
    如果对象在声明的同时马上进行的初始化操作，则称之为拷贝运算。例如：
        class1 A("af"); class1 B=A;
    此时其实际调用的是B(A)这样的浅拷贝操作。
    如果对象在申明之后，在进行的赋值运算，我们称之为赋值运算。例如：
        class1 A("af"); class1 B;
        B=A;
    此时实际调用的类的缺省赋值函数B.operator=(A);默认也可以认为是浅拷贝。
    对于缺省的赋值运算，如果对象域内没有heap上的空间，其不会产生任何问题。但是，如果对象域内需要申请heap上的空间，那么在析构对象的时候，就会连续两次释放heap上的同一块内存区域，从而导致异常。
    实际这个过程是通过成员复制来完成的，即将一个对象的成员值一一复制给另一对象的对应成员。
2.浅拷贝与深拷贝
    浅拷贝是默认的拷贝函数，B=A会把A中变量的的指针给B。但如果A析构了，B中成员就成了野指针。
    深拷贝是完全赋值，即给B中成员也分配内存空间。
3.重载拷贝与赋值
public class A
{
    public:
        ...
        A(A &a);//重载拷贝函数
        A& operator=(A &b);//重载赋值函数
        //或者 我们也可以这样重载赋值运算符 void operator=(A &a);即不返回任何值。如果这样的话，他将不支持客户代码中的链式赋值 ，例如a=b=c会被禁止!
    private:
    		...
}
4.参考网站
	http://www.cnblogs.com/alexusli/archive/2008/08/27/1277683.html

五、友元（函数）
1.定义
    有一类特殊的非成员函数，可以访问类的私有成员，它们被称为友元函数。
    除了友元函数，还有友元类和友元成员函数。
2.用途
    在为类重载二院运算符时，常常需要友元。
    重载类运算符*，A=B*2.1，等价于 A = B.operator*(2.1);
    但A = 2.1 * B通过不了。
    通过定义友元函数，Time operator*(double m,const Time& t);可以将上式与A = operator*(2.1,B)匹配。
3.创建
（1）将原型放在类声明中，并加上关键字friend。如：
	friend Time operator*(double m,const Time &t);
（2）编写函数定义。不用使用类限定符，如Time::。不要在定义中使用关键字friend。如：
	Time operator*(double m,const Time &t){ ... }


