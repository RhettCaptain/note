一、声明与定义
1.声明.h
class Point
{
public:
     void setPoint(int x, int y);
private:
     int xPos;
     int yPos;
};  	//要有分号的
2.定义.cpp
Point::setPoint(int x,int y){}
3.内联方法
    定义在类声明中的函数都将自动成为内联函数
    内联函数的特殊规则要求在每个使用它们的文件中都对其进行定义。
    也可在类声明外定义内联函数，使用inline限定符。
    最简便的方法是将内联定义放在定义类的头文件中。
4.特殊成员函数
    c++会自动提供下面这些成员函数
    -默认构造函数（如果没有定义构造函数）
    -默认析构函数（如果没有定义）
    -复制构造函数（如果没有定义）
    -赋值运算符（如果没有定义）
    -地址运算符（如果没有定义）

5.参考网站
	http://www.cnblogs.com/xiongxuanwen/p/4290086.html

二、构造函数与析构函数
1.成员名与参数名
    为了区分成员名和参数名，可以在成员名前面加前缀m_或在后面加后缀_
2.使用构造函数
    Stock food = Stock("hello");	//显式调用
    Stock food("hello");		//隐式调用
    Stock *pFood = new Stock("hello")	//动态分配
3.默认构造函数    
    隐式默认构造函数Stock::Stock(){}不做任何初始化工作。这样可以声明Stock stock;
    当且仅当没有定义任何构造函数时，编译器才会提供默认构造函数。
    如果为类定义了构造函数后，程序员就必须为它提供默认构造函数，即
    如果提供了Stock(const char* str),也必须提供Stock()，否则无法声明Stock stock;
    可以通过（1）提供默认值的方法Stock(const char* str = "hello")或
    （2）重载的方法Stock()来提供默认构造函数，但不要同时使用。
4.析构函数
    当对象过期时，程序调用析构函数完成清理工作。
    如果构造函数使用new来分配内存，则析构函数将使用delete来释放这些内存。
    如果构造函数没有使用new，析构函数没有需要完成的任务，使用隐式析构函数即可。
5.类内常量
    const int Months = 12;	//错误，在创建对象前没有用于存储值的空间
可用方法
（1）枚举
    enum {Months = 12};
    double costs[Moths];    
（2）static
    static const int Months = 12;
6.静态类成员
    不能在类声明中初始化静态成员变量，这是因为声明描述了如何分配内存，但并不分配内存。
对于静态类成员，可以在类声明之外使用单独的语句进行初始化（使用作用于运算符，但不使用static）。
这是因为静态类成员是单独存储的，而不是对象的组成部分。
对于不能在类声明中初始化静态数据成员的一种例外是，静态数据成员位整形或枚举型const。
如static int numStr; int StrBad::numStr=0;
7.静态类成员函数
    将成员函数声明为静态：
（1）不能通过对象调用静态成员函数。静态成员函数甚至不能使用this指针。
    如果在公有部分声明，则可以使用类名和作用域解析运算符来调用它，如StrBad::Howmany();
（2）由于静态成员函数不与特定的对象相关联，因此只能使用静态数据成员。
8.初始化列表
    成员初始化列表由逗号分隔的初始化列表组成（前面带冒号）。
它位于参数列表的右括号之后，函数体左括号之前。
如果数据成员的名称位mdata，并需要将它初始化位val，则初始化器为mdata（val）。
对于const常量往往需要这样初始化，因为在执行构造函数前就需要给变量分配内存。
除了常量，被声明为引用的类成员
但初始化列表不限于初始化常量。
    如：Queue::QUeue(int qs):qsize(qs),front(NULL),item(0){}
c++11允许在声明时直接初始化，
    如：class Classy{const int mem=20;...}


三、运算符重载
1.格式
operatorop(argument-list)
如Time operator+(const Time &t) const{...}
Time t1,t2,t3;
t3 = t1 + t2;	//相当于Time对象t1调用方法operator+()，参数是t2,并返回一个Time对象。(运算符表示法）
也可以使用 t3 = t1.operator+(t2);（函数表示法）

2.重载限制
（1）重载后的运算符，至少有一个操作数是用户定义的类型。
（2）使用运算符时不能违反运算符原来的句法规则和优先级。
（3）不能创建新运算符。
可重载的运算符：
+;-;*;/;%;^;&;|;~=;!;=;<;>;+=;-=;*=;/=;...
（4）不能重载下面运算符
-sizeof
-.	//成员运算符
-*	//成员指针运算符
-::	//作用域解析
-?:	//条件运算符
-typeid;const_cast;dynamic_cast;reinterpret_cast;static_cast


四、拷贝与赋值
1.定义
-拷贝：
    如果对象在声明的同时马上进行的初始化操作，则称之为拷贝运算。例如：
        class1 A("af"); class1 B=A;
    此时如果没有重载，则实际调用的是默认的复制构造函数。
    默认的复制构造函数原型通常为Class_name(const Class_name &);
    以下4种声明会调用复制构造函数(a是StrBad类的一个对象）
    StrBad b(a);		
    StrBad b = a;		
    StrBad b = StrBad(a);
    StrBad *b = new StrBad(a);	
    每当程序生成对象副本时，编译器都将使用复制构造函数。
即当函数按值传递对象或函数返回对象时，也将会用复制构造函数。
由于按值传递对象将调用赋值构造函数，因此应该按引用传递对象。
    默认的复制构造函数逐个复制/拷贝非静态成员（也称为浅复制/拷贝），
因此，成员涉及指针时应该特别注意。
-赋值
    如果对象在申明之后，在进行的赋值运算，我们称之为赋值运算。例如：
        class1 A("af"); class1 B;
        B=A;
    此时实际调用的类的缺省赋值函数B.operator=(A);默认也可以认为是浅拷贝。
    默认的赋值运算符原型为：
    Class_name & Class_name::operator=(const Class_name &);
    对于缺省的赋值运算，实际这个过程是通过成员复制来完成的，即将一个对象的非静态成员值一一复制给另一对象的对应成员。如果对象域内没有heap上的空间，其不会产生任何问题。但是，如果对象域内需要申请heap上的空间，那么在析构对象的时候，就会连续两次释放heap上的同一块内存区域，从而导致异常。
    对于赋值函数，应该
    -delete new的数据
    -应避免将对象赋给自身
    -函数返回一个指向调用对象的引用。
    
2.浅拷贝与深拷贝
    浅拷贝是默认的拷贝函数，B=A会把A中变量的的指针给B。但如果A析构了，B中成员就成了野指针。
    深拷贝是完全赋值，即给B中成员也分配内存空间。
3.重载拷贝与赋值
public class A
{
    public:
        ...
        A(A &a);//重载拷贝函数
        A& operator=(A &b);//重载赋值函数
        //或者 我们也可以这样重载赋值运算符 void operator=(A &a);即不返回任何值。如果这样的话，他将不支持客户代码中的链式赋值 ，例如a=b=c会被禁止!
    private:
    		...
}
4.参考网站
	http://www.cnblogs.com/alexusli/archive/2008/08/27/1277683.html

五、友元（函数）
1.定义
    有一类特殊的非成员函数，可以访问类的私有成员，它们被称为友元函数。
    除了友元函数，还有友元类和友元成员函数。
2.用途
    在为类重载二院运算符时，常常需要友元。
    重载类运算符*，A=B*2.1，等价于 A = B.operator*(2.1);
    但A = 2.1 * B通过不了。
    通过定义友元函数，Time operator*(double m,const Time& t);可以将上式与A = operator*(2.1,B)匹配。
3.创建
（1）将原型放在类声明中，并加上关键字friend。如：
	friend Time operator*(double m,const Time &t);
（2）编写函数定义。不用使用类限定符，如Time::。不要在定义中使用关键字friend。如：
	Time operator*(double m,const Time &t){ ... }

六、（成员函数）返回值
1.返回指向const对象的引用
    如果函数返回传递给它的对象，可以通过返回引用来提高效率。
    （1）返回对象将调用复制构造函数，而返回引用不会
    （2）引用指向的对象应该在调用函数执行时存在。
    （3）如果返回的是const引用，则返回类型必须位const。
2.返回指向非const对象的引用
    两种常见情形是：
    （1）重载赋值运算符――提高效率，可以连续赋值
    （2）重载与cout一起使用的<<运算符――必须如此，串接输出
3.返回对象
    如果被返回的对象是被调用函数中的局部变量，则不应按引用返回。
    因为在被调用函数执行完时，局部对象将调用其析构函数，引用指向的对象将不再存在。  
    重载算术运算符如+等常属于这种情况
4.返回const对象。
	如果担心赋值出错，即不允许左赋值，可以加上const。

六、继承
1.声明
class 派生类名:继承方式 基类名1,继承方式 基类名2,...,继承方式 基类名n
{
	派生类成员声明；
}
如
class DerivedClass : public BaseClass
{
	...
}
-派生类对象存储了基类的数据成员
-派生类对象可以使用基类的方法
-派生类需要自己的构造函数
-派生类可以更加需求添加额外的数据成员和成员函数

2.构造函数
派生类不能直接访问基类的私有成员，而必须通过基类方法进行访问。
因此，派生类构造函数必须使用基类的构造函数，如
DerivedClass::DerivedClass(int fn,int fm):BaseClass(fn,fm)
{
	rate = r;
}
:BaseClass(fn,fm)为成员初始化列表
如果不调用基类构造函数，程序将使用默认的基类构造函数，
因此，除非要使用默认的构造函数，否则应显式调用正确的基类构造函数。
---
构造函数不能是虚函数。
析构函数应当是虚函数，除非类不用做基类。

3.使用
要使用派生类，程序必须要能够访问基类声明。

4.派生类与基类的关系
（1）派生类对象可以使用基类方法（不是私有）
（2）基类指针可以在不进行显式类型转换的情况下指向派生类对象；
（3）基类引用可以在不进行显示类型转换的情况下引用派生类对象。
（4）基类指针或引用只能用于调用基类方法，而不能调用派生类的方法。

5.多态
（1）含义
同一个方法在派生类和基类的的行为是不同的，即方法的行为取决于调用该方法的对象。
（2）实现
-在派生类中重新定义基类的方法
    实际会有独立的方法定义，应为限定名不同。
    程序将使用对象类型来确定使用那个版本。
-使用虚方法
    如果方法是通过引用或指针而不是对象调用的，它将确定使用哪一种方法。
    如果没有使用关键字virtual，程序将根据引用类型或指针类型选择方法。
    如果使用了virtual，程序将根据引用或指针指向的对象的类型来选择方法。
   （即，使用virtual可以让引用和指针也根据实际对象选择方法，如同正常用对象调用一样。）
    ---
    经常在基类中将派生类会重新定义的方法声明为虚方法，
    方法在基类中被声明为虚的后，在派生类中将自动生成为虚方法。
    在派生类声明中用virtual指出虚函数也可以。 
    ---
    virtual只用于类声明的方法原型中，即定义中不需要。    
（3）虚析构函数
    当基类和派生类的析构函数不同时，在析构函数前加上virtual，确保正确的析构函数被调用。
    析构函数应当是虚函数，除非类不用做基类。
	
（4）转型
    将派生类引用或指针转换为基类引用或指针被称为向上强制转换（upcasting），通常是安全的，不需要显式转换。
    将基类指针或引用转换为派生类指针或引用称为向下强制转换（downcasting），不适用显示类型转换，是不允许的（通常不安全）。

七、模板类
1.格式
template<class  形参名，class 形参名，…>   class 类名
　　{ ... };
如 template<class T> class A{public: T a; T b; T hy(T c, T &d);};
2.参考
http://www.cnblogs.com/gw811/archive/2012/10/25/2738929.html

