一、声明与定义
1.声明.h
class Point
{
public:
     void setPoint(int x, int y);
private:
     int xPos;
     int yPos;
};  	//要有分号的
2.定义.cpp
Point::setPoint(int x,int y){}
3.内联方法
    定义在类声明中的函数都将自动成为内联函数
    内联函数的特殊规则要求在每个使用它们的文件中都对其进行定义。
    也可在类声明外定义内联函数，使用inline限定符。
    最简便的方法是将内联定义放在定义类的头文件中。
4.参考网站
	http://www.cnblogs.com/xiongxuanwen/p/4290086.html
	
二、构造函数与析构函数
1.成员名与参数名
    为了区分成员名和参数名，可以在成员名前面加前缀m_或在后面加后缀_
2.使用构造函数
    Stock food = Stock("hello");	//显式调用
    Stock food("hello");		//隐式调用
    Stock *pFood = new Stock("hello")	//动态分配
3.默认构造函数    
    隐式默认构造函数Stock::Stock(){}不做任何初始化工作。这样可以声明Stock stock;
    当且仅当没有定义任何构造函数时，编译器才会提供默认构造函数。
    如果为类定义了构造函数后，程序员就必须为它提供默认构造函数，即
    如果提供了Stock(const char* str),也必须提供Stock()，否则无法声明Stock stock;
    可以通过（1）提供默认值的方法Stock(const char* str = "hello")或
    （2）重载的方法Stock()来提供默认构造函数，但不要同时使用。

三、拷贝与赋值
1.定义
    如果对象在声明的同时马上进行的初始化操作，则称之为拷贝运算。例如：
        class1 A("af"); class1 B=A;
    此时其实际调用的是B(A)这样的浅拷贝操作。
    如果对象在申明之后，在进行的赋值运算，我们称之为赋值运算。例如：
        class1 A("af"); class1 B;
        B=A;
    此时实际调用的类的缺省赋值函数B.operator=(A);默认也可以认为是浅拷贝。
    对于缺省的赋值运算，如果对象域内没有heap上的空间，其不会产生任何问题。但是，如果对象域内需要申请heap上的空间，那么在析构对象的时候，就会连续两次释放heap上的同一块内存区域，从而导致异常。
    实际这个过程是通过成员复制来完成的，即将一个对象的成员值一一复制给另一对象的对应成员。
2.浅拷贝与深拷贝
    浅拷贝是默认的拷贝函数，B=A会把A中变量的的指针给B。但如果A析构了，B中成员就成了野指针。
    深拷贝是完全赋值，即给B中成员也分配内存空间。
3.重载拷贝与赋值
public class A
{
    public:
        ...
        A(A &a);//重载拷贝函数
        A& operator=(A &b);//重载赋值函数
        //或者 我们也可以这样重载赋值运算符 void operator=(A &a);即不返回任何值。如果这样的话，他将不支持客户代码中的链式赋值 ，例如a=b=c会被禁止!
    private:
    		...
}
4.参考网站
	http://www.cnblogs.com/alexusli/archive/2008/08/27/1277683.html
