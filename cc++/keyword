关键字
一、const
1.const初始化
const类型必须在编译或运行时初始化
const int i=getSize();//运行时初始化
const int j=1;//编译时初始化

2.外部使用const
如果要在多个文件间共享const对象，必须在变量的定义前添加extern
--file 1.c--
extern const int i=1;
--file 2.c--
extern const int i;
cout << i;

3.const 引用
const引用又称常量引用，必须声明为const
const int a=1;
const int &b = a;	//ok
b=1;//false
int &c=a;//false;
---
但const的引用可以指向非常量
int m=10;
const int &n = m;
//n不能改，但m可以改，进而改n

4.const常量指针和指针常量
    ---
    常量指针：指向常量的指针
    const位于星号的左侧，如：const int* a; int const *a;都是常量指针。
    指针可以变，但内容不可以变。a = &b可以。*a = 600是错误的。
    但b=600,a=&b可以使得*a变成600.或者a=&b,b=600,也可以。
    ---
    指针常量：指针本身是一个常量
    const位于星号的右侧，如：int* const a; 
    指针不能变，但所指的内容是可变的。
    int* const a=&b; //必须初始化
    *a = 600; 可以  a++不可以。
    ---
    const int* const a;  内容和指针都不能变的
    ---
    const char *const *key;  //是二级指针，const在第二个*之前表示二级指针指向的内容不可修改，但二级指针本身可以修改。

5.const成员函数
   void fun const(){}	//实际修饰的是this指针
（1）只有被声明为const的成员函数才能被一个const类对象调用。
（2）把一个成员函数声明为const可以保证这个成员函数不修改数据成员
（3）但是，如果据成员是指针，则const成员函数并不能保证不修改指针指向的对象，编译器不会把这种修改检测为错误。
二、static
1.修饰全局变量
  static修饰的全局变量声明与定义同时进行，
  static修饰全局变量的作用域只能是本身的编译单元，也就是说它的“全局”只对本编译单元有效（可链接性为内部）
	extern和static不能同时修饰一个变量；
2.修饰局部变量
  作用域为整个文件，而不是局部。
2.修饰成员函数
	将成员函数声明为静态：
（1）不能通过对象调用静态成员函数。静态成员函数甚至不能使用this指针。
    如果在公有部分声明，则可以使用类名和作用域解析运算符来调用它，如StrBad::Howmany();
（2）由于静态成员函数不与特定的对象相关联，因此只能使用静态数据成员。
类似，私有静态数据成员只能通过公有静态成员函数访问。

三、virtual

四、explicit
    消除构造函数定义的隐式转换

五、public；protected；private
（1）成员访问权限
private : 私有成员, 在类的内部才可以访问。
protected : 保护成员，该类内部和继承类中可以访问。
public : 公共成员，完全公开，没有访问限制。
（2）继承权限
private：私有继承，基类的公有成员和保护成员都将成为派生类的私有成员。
protected：保护继承，基类的公有成员和保护成员都将成为派生类的保护成员。
    与私有继承的主要区别在于，当派生类派生出另一个类时，
私有继承派生的不能使用基类接口，保护继承都可以。
public：公有继承，外部也可以是用基类的公有成员。只有公有继承的派生类才是真正意义的子类。
总结：说白了继承权限，就是基类的公有成员和保护成员变成什么类型的成员，然后参考（1）
