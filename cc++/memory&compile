内存与编译
一、内存模型
1.自动存储、静态存储和动态存储
（1）自动存储
	一般的变量声明都是自动存储，其生命周期和作用域为包含他的代码块。
（2）静态存储
	静态存储是整个程序执行期间都存在的存储方式，使其静态的方法有：在函数外定义它，或使用static声明
示例：
void inc(){ static int a=1; a++; cout << a << endl;}
int main(){inc();inc();inc();}
//输出1,2,3
（3）动态存储
	前两种都在栈（stack）中存储，使用new/delete在堆（heap）或自由存储空间（free store）存储，称为动态存储。前两者内存分配一般都是连续的，后者不连续，难以跟踪。

2.内存泄露
	new了但没delete会造成内存泄露。包含指针的内存由于作用域规则和对象生命周期的原因而释放，但内存上分配的变量或结构却继续存在。由于指向该内存的指针无效，故无法访问这块内存，导致内存泄露。
	内存泄露会导致内存耗尽，或则自身程序或相关程序崩溃。


二、编译
1.静态联编和动态联编
（1）概念：
-函数名联编（binding）：编译器将源代码中的函数调用解释为执行特定的函数代码块。
-静态联编（static binding）/早期联编（early binding）：
    在编译过程中进行联编，如c函数，重载函数。
-动态联编（dynamic binding）/晚期联编（late binding）：
    在运行时选择正确的代码，如虚函数的联编。
（2）比较
	静态联编比动态联编效率高，动态联编更灵活。
（3）虚函数工作原理
	编译器处理虚函数的方法是：给每个对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为虚函数表。
	使用虚函数时，在内存和执行速度方面有一定的成本，包括：
	-每个对象都将增大，增大量为存储地址的空间。
	-对于每个类，编译器都创建一个虚函数地址表（数组）
	-对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址。
