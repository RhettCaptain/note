1.定义全局变量,常量
extern：.h中extern char g_str[]  // 声明全局变量g_str
			.cpp中char g_str[] = " 123456"   // 定义全局变量g_str
static：static修饰的全局变量声明与定义同时进行，
				static修饰全局变量的作用域只能是本身的编译单元，也就是说它的“全局”只对本编译单元有效
				extern和static不能同时修饰一个变量；
				如.h中static char g_str[] = " 123456"   
const:const修饰的全局常量据有跟static相同的特性，即它们只能作用于本编译模块中，
			但是const可以与extern连用来声明该常量可以作用于其他编译模块中
			const的常量不可更改

2.获取数组长度
	sizeof((x)) / sizeof(x[0])

3.参数传递
	（1）值传递
		实际上是在函数内部创建了形参的副本，不改变形参的实际值。
	（2）引用传递
			操作的是形参地址上的值，只不过起了个别名，可以改变形参的实际值。
	（3）指针传递
			函数内部要对指针指向的对象进行操作才会改变形参，如
			void test(int *argc,char **args){
					*argc = 1;					//要对指向的对象赋值。
					*args = "abc";
				//char *tmp = *(args+1);  如果不行，不行加上这句试试
					*tmp = "def";
			}
			int main(int *argc,char **args){
				int a = 2;
				char **str = (char**)malloc(10);	//需要分配内存空间
				test(&a,str);
				cout << a << endl;	//输出1
				cout << *(str+1) <<endl;	//输出def
			}
			

4.虚函数与纯虚函数区别
虚函数为了重载和多态的需要，在基类中是有定义的，即便定义是空，所以子类中可以重写也可以不写基类中的此函数！
纯虚函数在基类中是没有定义的，必须在子类中加以实现，很像java中的接口函数！
（1）类里声明为虚函数的话,这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被重载，
这样的话，这样编译器就可以使用后期绑定来达到多态了
纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。
（2）虚函数在子类里面也可以不重载的；但纯虚必须在子类去实现，这就像Java的接口一样。
通常我们把很多函数加上virtual，是一个好的习惯，虽然牺牲了一些性能，但是增加了面向对象的多态性，
因为你很难预料到父类里面的这个函数不在子类里面不去修改它的实现
（3）虚函数的类用于“实作继承”，继承接口的同时也继承了父类的实现。当然我们也可以完成自己的实现。
纯虚函数的类用于“介面继承”，主要用于通信协议方面。关注的是接口的统一性，实现由子类完成。一般来说，介面类中只有纯虚函数的。
（4）带纯虚函数的类叫虚基类，这种基类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。这样的类也叫抽象类。
虚函数是为了继承接口和默认行为
纯虚函数只是继承接口，行为必须重新定义
---
虚函数
引入原因：为了方便使用多态特性，我们常常需要在基类中定义虚函数。
---纯虚函数
引入原因：
1、同“虚函数”；
2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。

5.（二维/高维/字符）数组传参，数组指针，指针数组
（1）可修改性
数组类型（数组名）是不可修改的，可以认为是const 指针，即指针常量。普通指针是可以修改的，但要分配内存
char a[3];
a="ab"	//不行
---
char* a;
a="ab"  //可以，但要分配内存a = new char[3];
（2）二维数组，数组指针和指针数组
char a[2][12];	//二维数组
a[1] = "adfa";  //不行，数组名虽然等价于指针，但是不可修改左值，指针可以修改
strcpy(a[0],"adfa");	//可以
---
char (*a)[12];	//数组指针，a是一个指针，指向一个有12个char元素的数组，即是一个二级指针
a[0] = "adfa";  //不行
strcpy(a[0],"adfa");//可以，但要先分配空间a = (char (*)[12])malloc(12);或a = (char(*)[12])new char*;
---
char* a[12];	//指针数组，一个数组，包含12个char*指针
a[1] = "adfa";  //可以
*a = "fd";	//可以
//但如果不是常量字符串，也要注意分配内存
（3）内存分配
一般按行分配
char a[2][2]
a[0][0] 0x00;a[0][1] 0x04;
a[1][0] 0x08;a[1][1] 0x0c;
a+1 = a[1] 0x08
（4）数组传参参数
void func(char s[10]);	//s类型 char*，注意：数组退化为指针 1）指针的变化是不影响外部的，除非去二级指针传参。2）这只是个指针，没有分配内存，但实参可能分配了。
void func(char s[10][20]);或void func(char s[][20]);或void func(char (*s)[20]);	//s类型 char (*)[20]，指针数组，s+1内存下移20个字节
    //s[1][2] 可以用*(*(s+1)+2)表示
void func(char* s[20]);或void func(char** s);	//s类型 char** 显然，不能使用s[1][2]这种，但可以通过行列用指针推算。s+1内存下移1个字节
    //s[1][2] 可以用*(s+1*20+2)表示 
---
可以将数组指针强制转换为一维指针，然后按照内存中存储的方法计算二维数组对应成一维数组的下标
    void test(int *a,int row,int column,int m,int n){ cout<<a[m*column+n];}
    int main(){int a[3][4]={{1,3,5,7},{9,11,13,15},{17,19,21,23}};test((int*)a,3,4,1,1);}
也可以将数组指针强制转换位二维指针，然后按照内存中存储的方法计算二维数组对应成一维数组的下标，建议用上一种方法。

6.i++与++i


7.强制类型转换
（1）数据存放
    一般计算机小端存储，如int a = 0x12345678,其地址存储如下：
    0x00000000(a) 0x78
    0x00000001    0x56
    0x00000002	  0x34
    0x00000003    0x12
    所以char b=(char)a为：0x5678
    ---
    一般变量存在栈中，char a,b; a的地址0x00000009;b的地址0x00000008
（2）符号扩展
    有符号扩展转型时保留符号，无符号扩展转型用零补全
    char a=0xff; unsigned char b=0xff;
    (int)a: 0xffffffff  (int)b:0x000000ff
（3）引用转型
    float a=1.0;
    (int&)a相当于将该浮点数地址开始的sizeof（int）个字节当成int型的数据输出。
    浮点型和整形在内存中的存储方式不同。不能这样转型。
（4）隐式类型转换
    在混合类型的算数表达式中，最宽的数据类型称为目标转换类型。如：
    int iv=3;  double dv=3.14;  iv+dv; (iv被提升位double)
    ---
    赋值给另一类型的对象，隐式转换为被赋值对象的类型。如：
    double dv=3.14;  int iv=dv;(被截断为3）
    ---
    类型与函数形参不同时，转型为形参类型，如：
    void func(double a); int b=2; func(b);(b转型为2.0）
    ---
    返回值与函数声明类型不同时，转型为声明类型，如
    int func(){return 3.14;}	(转型位3）
    ---
    通用指导准则：
    --一般来说，类型总是被提升为较宽的类型
    --所有含有小于整型的有序类型的算术表达式在计算之前其类型都会被转型为整型
    如：char a=0x7f;int b=0x7fffffff; cout << a+a; (输出254） cout << b+b; (输出-2)
        char a=0x01; cout << ~a>>4; (输出0xffffffff)

8.运算符优先级
（1）最高级
    ()  []  ->  .  ::  ++(i++)  --(i--)
（2）次高级
    !  ~  ++ (++i)  --(--i)  -  +  *(*ptr)  &  (type)  sizeof
（3）第三
    ->*   .*
（4）第四
    *(a*b)  /  %
（5）第五
    +  -
（6）第六
    <<  >>
（7）第七
    < <=  >  >=
（8）第八
    ==  !=
（9）其他
    第九：&  第十：^  第十一:|  第十二:&&  第十三：||  第十四：?:  第十五：=  +=  -=...  第十六：,
（10）例子
    a>>4+1  是右移5位

9.c与c++的区别
（1）c++支持函数重载，c语言不支持函数重载
    c++提供了c连接交换指定符号extern "c" 解决名字匹配问题。

10.宏定义，const和内联函数
（1）宏的括号陷阱
    #define SUB(x,y) x-y
    int main(){ cout << SUB(4,2)*2;} //输出0,实际的运算是4-2*2=0
    //应该修改宏为SUB(x,y) (x-y)
（2）const常量指针和指针常量
    ---
    常量指针：指向常量的指针
    const位于星号的左侧，如：const int* a; int const *a;都是常量指针。
    指针可以变，但内容不可以变。a = &b可以。*a = 600是错误的。
    但b=600,a=&b可以使得*a变成600.或者a=&b,b=600,也可以。
    ---
    指针常量：指针本身是一个常量
    const位于星号的右侧，如：int* const a; 
    指针不能变，但所指的内容是可变的。
    int* const a=&b; //必须初始化
    *a = 600; 可以  a++不可以。
    ---
    const int* const a;  内容和指针都不能变的
    ---
    const char *const *key;  //是二级指针，const在第二个*之前表示二级指针指向的内容不可修改，但二级指针本身可以修改。
（3）const成员函数
    int func() const;
    不改变类的数据成员。实际是this指针设为了常量。
    如果希望某个成员变量是const函数可修改的，可以加mutable修饰，如：mutable int m_count;
（4）const与#define比较
    --const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查，而对后者只进行字符替换，没有类型安全检查。
    --有些集成调试工具可以对const常量进行调试，但不能对宏常量进行调试。
    --c++程序只使用const常量而不是用宏常量，即const常量完全取代宏常量。
（5）内联函数和宏定义差别
    --在编译的时候内联函数可以直接被镶嵌到目标代码中，而宏只是一个简单的替换
    --内联函数要做参数类型检查，这是内联函数跟宏相比的优势。
    --内联函数在和相比没有付出任何额外代价的情况下更安全。
    --内联函数一般应用于1）一个函数不断被重复调用，2）函数只有简单的几行，且函数内不包含for，while，switch等语句
    --宏在C中很重要，但C++中用的少，第一规则是绝不使用它，除非你不得不这样做。


11.sizeof与数据对齐
（1）sizeof是运算符，不是函数。用于计算占用多少字节的内存。
     sizeof的参数可以是类型，如：sizeof（char） //1；
     也可以是变量，如:int a=10;sizeof(a);  //4
     包括指针和数组，如：char* s1="a"; char q1[3]="a";  sizeof(s1); //4  sizeof(q1); //3
     ---
     float：4  double：8  string：28  
指针一般是4，数组看分配的内存空间。
     计算类或结构体时，要注意数据对齐
（2）数据对齐
     数据所在内存地址必须是该数据长度的整数倍。
     计算类或结构体占用内存大小，要考虑数对齐。如：
     class A{private: bool m_b1; int m_i; bool m_b2;};
     |bool|----|----|----|
     |--------int--------|
     |bool|----|----|----|
     class B{int m_i;bool m_b1;bool m_b2;};
     |--------int--------|
     |bool|bool|----|----|
     sizeof(A);	//12  sizeof(B); //8
（3）静态变量，空类，继承类的大小
     静态变量存放在全局数据区，sizeof计算栈中分配的大小，故不算。函数好像也不算。
     空类占空间1，单一继承的空类空间也位1，多重继承的空类空间还是1.
     虚继承涉及虚指针，所以大小为4

12.const常量赋值时，必须同时初始化。
   类中的const常量要通过初始化列表初始化。

13.int a[3];
   int *p=a,*q=&a[2];
   a[q-p]中虽然q与p地址差了8，但q-p实际运算是8/4=2

14.句柄
    句柄是一个32位证书，实际上是windows内存中维护的一个对象。内存物理地址列表的整数索引。
    句柄是一种指向指针的指针。

