1.定义全局变量,常量
extern：.h中extern char g_str[]  // 声明全局变量g_str
			.cpp中char g_str[] = " 123456"   // 定义全局变量g_str
static：static修饰的全局变量声明与定义同时进行，
				static修饰全局变量的作用域只能是本身的编译单元，也就是说它的“全局”只对本编译单元有效
				extern和static不能同时修饰一个变量；
				如.h中static char g_str[] = " 123456"   
const:const修饰的全局常量据有跟static相同的特性，即它们只能作用于本编译模块中，
			但是const可以与extern连用来声明该常量可以作用于其他编译模块中
			const的常量不可更改

2.获取数组长度
	sizeof((x)) / sizeof(x[0])

3.参数传递
	（1）值传递
		实际上是在函数内部创建了形参的副本，不改变形参的实际值。
	（2）引用传递
			操作的是形参地址上的值，只不过起了个别名，可以改变形参的实际值。
	（3）指针传递
			函数内部要对指针指向的对象进行操作才会改变形参，如
			void test(int *argc,char **args){
					*argc = 1;					//要对指向的对象赋值。
					*args = "abc";
				//char *tmp = *(args+1);  如果不行，不行加上这句试试
					*tmp = "def";
			}
			int main(int *argc,char **args){
				int a = 2;
				char **str = (char**)malloc(10);	//需要分配内存空间
				test(&a,str);
				cout << a << endl;	//输出1
				cout << *(str+1) <<endl;	//输出def
			}
			

4.虚函数与纯虚函数区别
虚函数为了重载和多态的需要，在基类中是有定义的，即便定义是空，所以子类中可以重写也可以不写基类中的此函数！
纯虚函数在基类中是没有定义的，必须在子类中加以实现，很像java中的接口函数！
（1）类里声明为虚函数的话,这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被重载，
这样的话，这样编译器就可以使用后期绑定来达到多态了
纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。
（2）虚函数在子类里面也可以不重载的；但纯虚必须在子类去实现，这就像Java的接口一样。
通常我们把很多函数加上virtual，是一个好的习惯，虽然牺牲了一些性能，但是增加了面向对象的多态性，
因为你很难预料到父类里面的这个函数不在子类里面不去修改它的实现
（3）虚函数的类用于“实作继承”，继承接口的同时也继承了父类的实现。当然我们也可以完成自己的实现。
纯虚函数的类用于“介面继承”，主要用于通信协议方面。关注的是接口的统一性，实现由子类完成。一般来说，介面类中只有纯虚函数的。
（4）带纯虚函数的类叫虚基类，这种基类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。这样的类也叫抽象类。
虚函数是为了继承接口和默认行为
纯虚函数只是继承接口，行为必须重新定义
---
虚函数
引入原因：为了方便使用多态特性，我们常常需要在基类中定义虚函数。
---纯虚函数
引入原因：
1、同“虚函数”；
2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。

5.（二维/高维/字符）数组传参，数组指针，指针数组
（1）可修改性
数组类型（数组名）是不可修改的，可以认为是const 指针，即指针常量。普通指针是可以修改的，但要分配内存
char a[3];
a="ab"	//不行
---
char* a;
a="ab"  //可以，但要分配内存a = new char[3];
（2）二维数组，数组指针和指针数组
char a[2][12];	//二维数组
a[1] = "adfa";  //不行，数组名虽然等价于指针，但是不可修改左值，指针可以修改
strcpy(a[0],"adfa");	//可以
---
char (*a)[12];	//数组指针，a是一个指针，指向一个有12个char元素的数组，即是一个二级指针
a[0] = "adfa";  //不行
strcpy(a[0],"adfa");//可以，但要先分配空间a = (char (*)[12])malloc(12);或a = (char(*)[12])new char*;
---
char* a[12];	//指针数组，一个数组，包含12个char*指针
a[1] = "adfa";  //可以
*a = "fd";	//可以
//但如果不是常量字符串，也要注意分配内存
（3）内存分配
一般按行分配
char a[2][2]
a[0][0] 0x00;a[0][1] 0x04;
a[1][0] 0x08;a[1][1] 0x0c;
a+1 = a[1] 0x08
（4）数组传参参数
void func(char s[10]);	//s类型 char*，注意：数组退化为指针 1）指针的变化是不影响外部的，除非去二级指针传参。2）这只是个指针，没有分配内存，但实参可能分配了。
void func(char s[10][20]);或void func(char s[][20]);或void func(char (*s)[20]);	//s类型 char (*)[20]，指针数组，s+1内存下移20个字节
    //s[1][2] 可以用*(*(s+1)+2)表示
void func(char* s[20]);或void func(char** s);	//s类型 char** 显然，不能使用s[1][2]这种，但可以通过行列用指针推算。s+1内存下移1个字节
    //s[1][2] 可以用*(s+1*20+2)表示 
---
可以将数组指针强制转换为一维指针，然后按照内存中存储的方法计算二维数组对应成一维数组的下标
    void test(int *a,int row,int column,int m,int n){ cout<<a[m*column+n];}
    int main(){int a[3][4]={{1,3,5,7},{9,11,13,15},{17,19,21,23}};test((int*)a,3,4,1,1);}
也可以将数组指针强制转换位二维指针，然后按照内存中存储的方法计算二维数组对应成一维数组的下标，建议用上一种方法。

6.i++与++i


7.强制类型转换
（1）数据存放
    一般计算机小端存储，如int a = 0x12345678,其地址存储如下：
    0x00000000(a) 0x78
    0x00000001    0x56
    0x00000002	  0x34
    0x00000003    0x12
    所以char b=(char)a为：0x5678
    ---
    一般变量存在栈中，char a,b; a的地址0x00000009;b的地址0x00000008
（2）符号扩展
    有符号扩展转型时保留符号，无符号扩展转型用零补全
    char a=0xff; unsigned char b=0xff;
    (int)a: 0xffffffff  (int)b:0x000000ff
（3）引用转型
    float a=1.0;
    (int&)a相当于将该浮点数地址开始的sizeof（int）个字节当成int型的数据输出。
    浮点型和整形在内存中的存储方式不同。不能这样转型。
（4）隐式类型转换
    在混合类型的算数表达式中，最宽的数据类型称为目标转换类型。如：
    int iv=3;  double dv=3.14;  iv+dv; (iv被提升位double)
    ---
    赋值给另一类型的对象，隐式转换为被赋值对象的类型。如：
    double dv=3.14;  int iv=dv;(被截断为3）
    ---
    类型与函数形参不同时，转型为形参类型，如：
    void func(double a); int b=2; func(b);(b转型为2.0）
    ---
    返回值与函数声明类型不同时，转型为声明类型，如
    int func(){return 3.14;}	(转型位3）
    ---
    通用指导准则：
    --一般来说，类型总是被提升为较宽的类型
    --所有含有小于整型的有序类型的算术表达式在计算之前其类型都会被转型为整型
    如：char a=0x7f;int b=0x7fffffff; cout << a+a; (输出254） cout << b+b; (输出-2)
