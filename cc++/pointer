指针
1.声明和初始化
int *p_ptr;		//强调*p_ptr是一个int类型的值
int* p_ptr;		//强调int*是一种类型——指向int的指针
可以说p_ptr是指向int型的指针,或int*型，而*p_ptr是int，不是指针。
！！！但标准的说法只有第一种，
int *p1, *p2 定义两个指针;
int* p1,p2  p1是指针，p2是整形
---
int higgens = 5;
int *pt = &higgens;	//初始化
初始化的重要性：
	int *fellow;	//没有初始化（迷途指针）,应该new int。
	*fellow = 2233;	//将数据2233赋值给fellow，但fellow并没有给定的地址。会造成致命错误。
	一定要在对指针应用解除应用运算符（*）前，将指针初始化为一个确定的，适当的地址。
指针不是数字
	int* pt;
	pt = 0xB8000000;	//wrong
	pt = (int *)0xB80000;	//right
---
引用不是对象，不能定义指向引用的指针。但指针是对象，可以由对指针的引用
int *p;
int *&r = p;

2.内存分配
（1）C —— malloc()
原型：extern void *malloc(unsigned int num_bytes);
头文件：#include <malloc.h> 或 #include <alloc.h>
功能：分配长度为num_bytes字节的内存块
说明：如果分配成功则返回指向被分配内存的指针，否则返回空指针NULL。
当内存不再使用时，应使用free()函数将内存块释放。
举例：
	char *p; 
	p=(char *)malloc(sizeof(char) * 10);  
	free(p);  
（2）C++ —— new
原型：typeName* pointer_name = new typeName;
说明：声明的常规变量都存储在栈（stack）内存，new的内存一般在堆（heap）内存或自由存储区（free store）
    在使用完内存后，使用delete能够将其归还给内存池。
举例：
	int* pn = new int;
	delete pn;	//right
	delete pn;	//wrong
     	int s = 5;
	int* ps = &s;
	delete ps;	//wrong,只能删除new的指针。

3.使用new创建动态数组
	int* psome = new int[10];	//创建包含10个int的动态数组，但不能用sizeof判断数组字节。
	psome = new int[12];		//重新分配内存，之前的数据丢失。且应该先delete。
	psome[12] = 10;			//能赋值，但delete会出错，在地址后面紧跟着new同理。
	delete[] psome;	//[]告诉程序释放整个数组，而不是一个元素。
	
4.数组地址
	数组地址不等于数组名，虽然数值一样，但含义不同
	short tell[10];
	cout << tell << endl;	//&tell[0],一个2字节内存块地址。tell+1，地址+2
	cout << &tell << endl;	//整个数组地址，一个20字节内存块地址。&tell+1，地址+20
	short (*ptr)[10] = &tell;	//ptr类型为short(*)[10]，即10位short数组的指针。

5.指针与字符串
	char数组，char指针以及字符串常量都被解释成字符串第一个字符的地址。
	char* ps;	//未初始化
	const char* str="test";	//常量，不能修改，字符串常量本身也不该被修改。
	char arr[10];	//字符串数组
	cout<<ps;	//可能乱码或崩溃！
	cin>>ps;	//糟糕的尝试，可能成功，但有隐患。
	cin>>str;	//有些编译器会报错，建议不要使用
	cin>>arr;	//小于9个没问题，可以用足够大的数组接受，或者使用string

6.（二维/高维/字符）数组传参，数组指针，指针数组
（1）可修改性
数组类型（数组名）是不可修改的，可以认为是const 指针，即指针常量。普通指针是可以修改的，但要分配内存
char a[3];
a="ab"	//不行
---
char* a;
a="ab"  //可以，但要分配内存a = new char[3];
（2）二维数组，数组指针和指针数组
char a[2][12];	//二维数组
a[1] = "adfa";  //不行，数组名虽然等价于指针，但是不可修改左值，指针可以修改
strcpy(a[0],"adfa");	//可以
---
char (*a)[12];	//数组指针，a是一个指针，指向一个有12个char元素的数组，即是一个二级指针
a[0] = "adfa";  //不行
strcpy(a[0],"adfa");//可以，但要先分配空间a = (char (*)[12])malloc(12);或a = (char(*)[12])new char*;
---
char* a[12];	//指针数组，一个数组，包含12个char*指针
a[1] = "adfa";  //可以
*a = "fd";	//可以
//但如果不是常量字符串，也要注意分配内存
（3）内存分配
一般按行分配
char a[2][2]
a[0][0] 0x00;a[0][1] 0x04;
a[1][0] 0x08;a[1][1] 0x0c;
a+1 = a[1] 0x08
（4）数组传参参数
void func(char s[10]);	//s类型 char*，注意：数组退化为指针 1）指针的变化是不影响外部的，除非去二级指针传参。2）这只是个指针，没有分配内存，但实参可能分配了。
void func(char s[10][20]);或void func(char s[][20]);或void func(char (*s)[20]);	//s类型 char (*)[20]，指针数组，s+1内存下移20个字节
    //s[1][2] 可以用*(*(s+1)+2)表示
void func(char* s[20]);或void func(char** s);	//s类型 char** 显然，不能使用s[1][2]这种，但可以通过行列用指针推算。s+1内存下移1个字节
    //s[1][2] 可以用*(s+1*20+2)表示 
---
可以将数组指针强制转换为一维指针，然后按照内存中存储的方法计算二维数组对应成一维数组的下标
    void test(int *a,int row,int column,int m,int n){ cout<<a[m*column+n];}
    int main(){int a[3][4]={{1,3,5,7},{9,11,13,15},{17,19,21,23}};test((int*)a,3,4,1,1);}
也可以将数组指针强制转换位二维指针，然后按照内存中存储的方法计算二维数组对应成一维数组的下标，建议用上一种方法。

7.const常量指针和指针常量
    ---
    常量指针：指向常量的指针
    const位于星号的左侧，如：const int* a; int const *a;都是常量指针。
    指针可以变，但内容不可以变。a = &b可以。*a = 600是错误的。
    但b=600,a=&b可以使得*a变成600.或者a=&b,b=600,也可以。
    ---
    指针常量：指针本身是一个常量
    const位于星号的右侧，如：int* const a; 
    指针不能变，但所指的内容是可变的。
    int* const a=&b; //必须初始化
    *a = 600; 可以  a++不可以。
    ---
    const int* const a;  内容和指针都不能变的
    ---
    const char *const *key;  //是二级指针，const在第二个*之前表示二级指针指向的内容不可修改，但二级指针本身可以修改。
8.指针与引用的区别
（1）非空区别
    在任何情况下，都不能使用指向空值的引用，一个引用必须是指向某些对象的。但指针可以不指向任何对象。
    不存在指向空值的引用和这个事实意味着使用引用的代码效率比使用指针要高。
（2）合法性区别
    在使用引用前不需要测试合法性。指针则应该被测试，防止其为空。
（3）可修改区别
    指针可以被重新赋值以指向另一个不同的对象。但引用则总是指向在初始化时被指定的对象，以后不能改变，但指定的对象的内容可以改变。
（4）应用区别
    一般指针用于：1）考虑到存在不指向任何对象的可能。2）需要能够在不同的时刻指向不同的对象。
    一般引用用于：总是指向一个对象，且不会改变指向。

9.迷途指针和空指针
    迷途指针也叫悬浮指针、失控指针，是当对一个指针进行delet操作后，却没有把它设置为空产生的。
如果没有重新赋值就试图再次使用该指针（此时所指内存以被释放，且可能被用于他用），将会引起严重的后果。
    好的做法是delete后将迷途指针改为空指针，虽然使用空指针也非法，也会造成程序崩溃，但结果是可预料的。
